# -*- coding: utf-8 -*-
"""Deloitte Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pj80bS94facPR0-j5WAl5uHzlgirmdiP
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from textblob import TextBlob

# loading data
raw = pd.read_csv('/content/Final_Traffic_Data.csv')
raw.head()

raw.info()

#to process date_time column 
raw.date_time = pd.to_datetime(raw.date_time)
raw.date_time

#getting month number from series
months = raw.date_time.dt.month
months

#getting day number 
day_of_months = raw.date_time.dt.day
day_of_months

hours = raw.date_time.dt.hour
hours

to_one_hot = raw.date_time.dt.day_name()
# applying one hot encoding
days = pd.get_dummies(to_one_hot)

print(days)

def daypart(hour):
    if hour in [2,3,4,5]:
        return "dawn"
    elif hour in [6,7,8,9]:
        return "morning"
    elif hour in [10,11,12,13]:
        return "noon"
    elif hour in [14,15,16,17]:
        return "afternoon"
    elif hour in [18,19,20,21]:
        return "evening"
    else: return "midnight"

raw_dayparts = hours.apply(daypart)

dayparts = pd.get_dummies(raw_dayparts)

dayparts = dayparts[['dawn','morning','noon','afternoon','evening','midnight']]

#display data
print(dayparts)

#is_weekend column
day_names = raw.date_time.dt.day_name()
is_weekend = day_names.apply(lambda x : 1 if x in ['Saturday','Sunday'] else 0)

#is_holiday column
is_holiday = raw.holiday.apply(lambda x : 0 if x == "None" else 1)

#one-hot encode
weathers = pd.get_dummies(raw.weather_main)

#display data
print(weathers)

sentiment = raw.weather_description.apply(lambda x: 
                   TextBlob(x).sentiment.polarity)

print(sentiment)

#including the features with single column nature

features = pd.DataFrame({
    'temp' : raw.temp,
    'rain_1h' : raw.rain_1h,
    'snow_1h' : raw.snow_1h,
    'clouds_all' : raw.clouds_all,
    'month' : months,
    'day_of_month' : day_of_months,
    'hour' : hours,
    'is_holiday' : is_holiday,
    'is_weekend' : is_weekend,
    'sentiment_val': sentiment
})


#concating with one-hot encode typed features
features = pd.concat([features, days, dayparts, weathers], axis = 1)


target = raw.traffic_volume
print(features.info())

#splitting data
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.3, shuffle = False)

from sklearn import datasets, ensemble


# Gradient Boosting Regressor
params = {'n_estimators': 500,
          'max_depth': 6,
          'min_samples_split': 5,
          'learning_rate': 0.1,
          'loss': 'ls'}

gb_reg = ensemble.GradientBoostingRegressor(**params)


"""
# Random Forest Regressor
params = {'n_estimators': 500,
          'max_features': 0.25}

gb_reg = ensemble.RandomForestRegressor(**params)

params = {'n_estimators' : 1000,
          'max_features':"log2",
          'criterion' : "entropy"}
gb_reg = ensemble.ExtraTreesRegressor(**params)
"""

gb_reg.fit(X_train, y_train )

#importing r2 score
from sklearn.metrics import r2_score

#evaluating the metrics
y_true = y_test
y_pred = gb_reg.predict(X_test)

print(f"Model R2 is {round(r2_score(y_true, y_pred)* 100 , 2)} %")

test = pd.read_csv('/content/TrafficVolume_Test.csv')
test. columns = test. columns. str. replace(' ','_')
test.info()

test.Date_Time = pd.to_datetime(test.Date_Time)

months = test.Date_Time.dt.month

hours = test.Date_Time.dt.hour

to_one_hot = test.Date_Time.dt.day_name()
# applying one hot encoding
days = pd.get_dummies(to_one_hot)

day_of_months = test.Date_Time.dt.day

def daypart(hour):
    if hour in [2,3,4,5]:
        return "dawn"
    elif hour in [6,7,8,9]:
        return "morning"
    elif hour in [10,11,12,13]:
        return "noon"
    elif hour in [14,15,16,17]:
        return "afternoon"
    elif hour in [18,19,20,21]:
        return "evening"
    else: return "midnight"

test_dayparts = hours.apply(daypart)

dayparts = pd.get_dummies(test_dayparts)

dayparts = dayparts[['dawn','morning','noon','afternoon','evening','midnight']]

#is_weekend column
day_names = test.Date_Time.dt.day_name()
is_weekend = day_names.apply(lambda x : 1 if x in ['Saturday','Sunday'] else 0)

#is_holiday column
is_holiday = test.Holiday.apply(lambda x : 0 if x == "None" else 1)

#one-hot encode
weathers = pd.get_dummies(test.Weather_Main)

sentiment_test = test.Weather_Detail.apply(lambda x: 
                   TextBlob(x).sentiment.polarity)

test_df = pd.DataFrame({
    'temp' : test.Temp,
    'rain_1h' : test.Rain,
    'snow_1h' : test.Snow,
    'clouds_all' : test.Cloud,
    'month' : months,
    'day_of_month' : day_of_months,
    'hour' : hours,
    'is_holiday' : is_holiday,
    'is_weekend' : is_weekend,
    'sentiment_val': sentiment_test
})

#concating with one-hot encode typed features
test_df = pd.concat([test_df, days, dayparts, weathers], axis = 1)

feature_difference = set(X_test) - set(test_df)

feature_difference_df = pd.DataFrame(data=np.zeros((test_df.shape[0], len(feature_difference))),
                                     columns=list(feature_difference))
test_df = pd.concat([test_df,feature_difference_df],axis = 1)
test_df.info()

X_test.info()

test_pred = gb_reg.predict(test_df)

print(test_pred)

test_pred_df = pd.DataFrame(data = test_pred, 
                  columns = ['Prediction'])
test_pred_df.dropna(subset = ["Prediction"], inplace=True)
print(test_pred_df)
test_pred_df.info()

#pf = df[['temp','']]
test_pred_df.to_csv('file3.csv', index=False)